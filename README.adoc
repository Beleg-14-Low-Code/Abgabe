= Low-Code Ansatz zur Anwendungsprogrammierung
Elisabeth Lorenz, Erik Semmler, Galiia Shaekhova, Luisa Schnebelt 
:toc:
:toc-title: Gliederung

== Motivation

Statistik der unbesetzten stellen von It-Kräften in deutschland. Die Anzahl steigt stetig. Es wird erkennbar, dass im jahr 2019 die zahl enorm Anstieg, dies hat hauptsächlich die Coronapandemie zu Schulden.


Hintergedanke von Low-Code: Menschen mit wenige Programmierkenntnisse können Anwendungen entwickeln.
Boilerplatecode → Abnahmen von trivialen aufgaben, dinge die man immer machen musst
Missverständnisse bei den Anforderungen 
Wartungskosten

Ergebnis Metaanalyse von 2020: Verhältnis von Softwarewartungs- und Entwicklungskosten, Mittelwerte aus einschlägigen wissenschaftlichen Arbeiten
Reduktion ermöglicht durch:
???
Softwareentwicklern werden “triviale” Aufgaben abgenommen
dadurch entsteht mehr Zeit für Aufgaben wie Problemlösung oder Algorithmenentwicklung (wofür Devs ja ausgebildet werden)
Boilerplate Code wird für templates mit generiert, Benutzeroberfläche kann 
It- Kräfte an Mangel 

== Generationen von Programmiersprachen

Low Code lässt sich in den Generationen der Programmiersprachen in die 4. Generation, die Deklarative Programmierung einordnen. 
Programmierparadigmen: ist der stil in dem eine Programmiersprache entworfen wurde


1GL:
Maschinensprache: Wie der Name bereits erläutert, gab es in der ersten Generation eine Sprache, die nur Computer verstehen konnten. Dies kann durch den Prozessors eines Computers gelesen werden und besteht aus binären und digitalen Sprachen. 
Beispiel: 

2Gl:
Assemblersprache: Der Assembler übersetzt den Assembler Programmcode/ Quellcode in ein Maschinenprogramm. Assembler Code ist für den Menschen lesbar. Erschien erstmals im Jahr 1948
Nachteile Schlechte Lesbarkeirt und wartbarkeit, ist an einem Prozesor gebunden 
Beispiel Sprache: Fortran
→ dabei Anwendungen wurden immer Komplexer, es war sehr Zeitaufwendig. Entwickler brauchten mehr Zeit, es scheiterten viele Projekte. Budget wurd gesprengt

1960er erste Softwarekrise → neue sprechen wurden eingeführt
3GL:
Prozedurale Programmierung: Die Prozedurale Programmierung ist ein Paradigma der imperativen Programmiersprache. Es definiert eine Sequentieller/ Strukturierten Ablauf von Befehlen. Wiederverwendbare Teile werden in Funktionen ausgelagert, diese müssen vom Programmierer verstanden werden.  Sie besteht aus folgen anweisungen und verschiedenen Kontrollstrukturen ( schleifen, if-bedingungen, etc….).  → Strukturierte Programierung 
in den 1970 mit der Programiersprache pascal
1970 ebenfalls objektorientierte programmiersprach
Objektorientierter Ansatz wurde 1990 in den meidsten programmiersprachen eingeführt 

→ nichte mehr prozessor abhängig


4GL. 
Ziel der Sprache höheres Abstraktniveu
Was bedeutet Abstraktion:
Vereinfachung, Kernproblem bleibt vorhanden→ auf des wesentliche konzentrieren

Nochmal mit zeitangaben Programmiersprachen
■ 1950er- bis 1960er-Jahre: 
Programmiersprache ist Assemblersprach 
Ablauf wird durch ein Flussdiagramm dargestellte

■ 
1970er-Jahre: 
Strukturierende, Dominierende programmiersprachen 
beispiel Pascal
strukturierendedarstellungstechniken werden angewendet, wie strukturierendes design
software prozesse orientieren sich am wasserfallmodell 

■ Ab 1990er-Jahre: 
Objektorientiertprogrammiersprachen werden immer belieber C++, java
Vereinheilichender prozess durch Unified Modeling Language (UML), 
orientiert sich am spiralmodell (UML)


== Model Dricen Development (MDD)

1990: AT&T-Fernverkehrsnetz im Nordosten brach zusammen 
Grund: fehlende Break Anweisung 
kleine kodierungsfehler unerwartete folgen 
Problem von Softwareentwickler und Designer entwicklung von Software ist sehr kommplex
kann diese Komplexität eingegrenzt werden durch mdd? 
Wenn wir zum Beispiel versuchen einen Wolkenkratzer ohne den Einsatz von modernenWerkzeuge wie Bulldozer und hydraulische Hebevorrichtungen zu bauen, ist zwar theoretisch machbar, aber wahrscheinlich eine sehr komplexe Aufgabe sein. Die einzig mögliche Lösung für den der zunehmenden Komplexität ist die Minimierung des Grad der zufälligen Komplexität zu minimieren.

MDD

Modelle sind zum Beispiel auch in Ingenieurwesen sehr wichtig. 
Enginere benutzen zum beispiel mathematische model um die tragfähigkeit zu analysieren 
Problem: 
Modelle werden von Hand in Code geschrieben, daher gibt es keine formale Verbindung zwischen modell und Programmcode 
Schwierig modell zu pflegen, ist mit viel aufwand verbunden und implementierungen aktuelle zu halten ist schwierig. 
Deswegen sind modelle ungenau, oft auch aufgrund von Zeitdruck 
Dokumentation deswegen nicht vertrauenswürdig

Unterschied modellbasiert und Modellgetrieben: modellbasiert wird modellerstellt und code per hand geschrieben. Dient zur Dokumentation 
Modellgetrieben nach erstellunge des modelles wird automatisch code generiert. 
Geschichte von MDD
Hohe Softwarekosten auswirkungen für Unternehmen, aber noch schlimmer ist ein schlechtes softwaredesign, das die produktivität beeinflusst
Statistiken besagen, dass ca. 70% der Software-Projekte Budget und Termin überschreiten → anhaltenden Software-Krise.

Geschichte hier nochmal rausschreben → was ist OMG
http://eddi.informatik.uni-bremen.de/SUSE/pdfs/Diplomarbeit_Radek_Eckert.pdf

andere Quellen 
Formale Modelle werden Automatisiert und lauffähiger Code wird generiert, in code übersetzt→ in lauffähige software übersetzt 
Formale Modelle besitzen eindeutige Syntax und Semantik, Beispiel hierfür ist UML (Besispeil Tool, Enterprise Architekture
anstelle der dokumentation wird durch modellierung programmcode erstellt

https://swa.informatik.uni-hamburg.de/files/abschlussarbeiten/Diplomarbeit%20Michael%20Wilk%20final.pdf

Automatisiert den Entwicklungsprozess
ziel: Kosten senken, schwierigkeitsgrad reduzieren, Qualität verbessern 
Prozess generiert das fertige Endprodukt
Im gegensatz zu gewöhnlichen softwareentwicklungsprozessen, geht es nicht um dokumentation und analyse sondern um die entwicklung entwicklungsansatz)
Normalerweise werden Modelle als Dokumentation benutzt
Entwickler haben kein wissen über den 	Quellcode

== Low Code

Low-Code ermöglicht es Personen ohne großen Programmierkenntnissen eine Anwendung zu erstellen. Somit sind Unternehmen nicht auf IT-Spezialisten angewiesen. Zum einen kann die IT-Abteilung entlastet werden und zum anderen können die Anwendungsanforderungen spezifischer gestaltet werden, da Experten des Themengebiet die Anforderungen am besten kennen. 

Mithilfe von Low-Code können mit einer Drag- und Drop-Funktion Eingabe-, Navigation-, Dropdown-Felder und Steuerelemente hinzugefügt werden. Es können verschiedene Bildschirmansichten erstellt werden, diese werden mit Hilfe von  Steuerelementen miteinander verknüpft. 

Programmierung läuft über eine grafische Benutzeroberfläche.
Entwicklungsumgebung mit der code erstellt wird
Es wird über eine grafische oberfläche code projeziert
forster research hat den begriff ins leben gerufen 


Geeignet für sogenannte Citizen Developers: 
können Programme entwickeln, können aber keine genaue Programmiersprache. Kennen sich im Bereich aus. In der Programmierung verlassen sie sich auf das Tool. Nutzer sind auch Entwicklung. 

=== Ziele von Low Code

Einbeziehen von CItizen Developers in Modellierung von Geschäftsabläufen, da Sie schon damit vertraut sind
Low-Code ermöglicht es Personen ohne großen Programmierkenntnissen eine Anwendung zu erstellen. Somit sind Unternehmen nicht auf IT-Spezialisten angewiesen. Zum einen kann die IT-Abteilung entlastet werden und zum anderen können die Anwendungsanforderungen spezifischer gestaltet werden, da Experten des Themengebiet die Anforderungen am besten kennen. 

Mithilfe von Low-Code können mit einer Drag- und Drop-Funktion Eingabe-, Navigation-, Dropdown-Felder und Steuerelemente hinzugefügt werden. Es können verschiedene Bildschirmansichten erstellt werden, diese werden mit Hilfe von  Steuerelementen miteinander verknüpft. 

Programmierung läuft über eine grafische Benutzeroberfläche.
Entwicklungsumgebung mit der code erstellt wird
Es wird über eine grafische oberfläche code projeziert
forster research hat den begriff ins leben gerufen 


Geeignet für sogenannte Citizen Developers: 
können Programme entwickeln, können aber keine genaue Programmiersprache. Kennen sich im Bereich aus. In der Programmierung verlassen sie sich auf das Tool. Nutzer sind auch Entwicklung.  von Wartungskosten in Softwareentwicklung
siehe: https://dl.gi.de/handle/20.500.12116/37795
leicht zusammengestellt werden
Schnelligkeit: 5- 10 mal schneller als traditionelle programmierung
Kosteneinsparung:
Weniger Komplex: Fokus liegt darauf software individuell anzupassen und Benutzeranforderungen zu erfüllen 
Einfache wartungsarbeiten: → wenig code anbieten wenig code muss gewartet werden. 
Wenig technische Anforderungen erforderlich. Dadurch Abteilungsleiter die sich mit dem technischen nicht auskennen aber dafür viel fachliches wissen haben. könne beser anforderunge spezifizieren 

=== Architektur von Low Code

Visual Application Modeler: 
Das Fronte-end der Platform damit arbeitet der Entwickler
Entwicklungen und implementiert alle funktionalitäten mit den ein entwickler interagiert, wie code erstellung (grafisch oder mit text) Debugging, Datenmodellierung, debugging, testen, Anwendungsversionen
Encoder:
Exportiert visuelle Anwendungsmodell  in ein json oder xml Format exportiert, ohne das Funktionalitäten verloren gehen. 
Decoder:
 Interpretiert die encodierten Daten 
Source Code Generator: 
Aus dem Format wird ein Quellcode generiert. Dies können unterschiedliche Sprachen sein. Skripte müssen enthalten sein, um mit einer Datenbank zu arbeiten. 
Compiler: Quellcode wir compiliert, geprüft ob der code correct ist
Deployer: Software bereitstellen. Zum beispiel Webanwendung


== Vergleich von Low Code und traditioneller Programmierung an Anwendungsbeispiel

=== Vorstellung Anwendungsbeispiel

Wir haben als Beispiel beschlossen, eine Anwendung zu entwickeln, die den Prozess der Meldung eines Unfalls, der den versicherten Gegenständen eines Nutzers zugestoßen ist, vereinfacht.
Mit dieser App kann man: 
das versicherte Objekt des Benutzers auswählen,
einen der vier Vorfälle auswählen und die Einzelheiten des Vorfalls eintragen,
Nach Eintragung der wichtigsten Angaben können Bilder des Schadens hochgeladen werden.
Anschließend können weitere Details des Unfalls genannt werden. 
Zum Schluss erhält der Nutzer eine Übersicht und kann die Reklamierung absenden.

=== verwendete Werkzeuge

Im Vergleich zur traditionellen Programmierung ermöglicht es Low-Code eine Anwendung ohne große Programmierkenntnisse, mittels einer grafischen Oberfläche zu entwickeln. 
Der Code wird automatisch erzeugt. 
Um diese Aussage zu testen, haben wir zwei Webanwendungen mit der Programmiersprache JavaScript und der Low-Code-Plattform Mendix entwickelt. 


==== ReactJS etc.

Für die JavaScript-Entwicklung wurden die Bibliotheken React und React-Bootstrap gewählt, um die Benutzeroberfläche zu erstellen. React ermöglicht es, eine interaktive Benutzeroberfläche zu erstellen, und React-Bootstrap bietet eine einfache Anpassung der Stile, ohne dass große CSS-Dateien erstellt werden müssen. Für das Backend wurden Node.js und eine MySQL-Datenbank verwendet.

==== Mendix

=== Vergleich

==== GUI


GUI steht für "Graphical User Interface" und bezieht sich auf die Art und Weise, wie ein Computerprogramm oder ein Betriebssystem dargestellt wird. Es nutzt Bilder und Symbole anstelle von Textbefehlen, um dem Benutzer die Interaktion mit dem Computer zu erleichtern.

TP
Bei der Entwicklung in JavaScript gibt es keine grafische Benutzeroberfläche. Alle einzelnen Komponenten und Styles werden zunächst blind hinzugefügt, ohne zu wissen, wie die endgültige Benutzeroberfläche aussehen wird. Beim Start der Anwendung kann der Entwickler das Layout der einzelnen Komponenten im Code oder zunächst im Entwicklertool einrichten und dann alles in seinen Code übernehmen.

Mendix
Domänenmodell: Grafische Darstellung einer Datenbank. Besteht aus Entäitäten. Vergleichbar mit einer Datenbanktabelle. 
Auf der Seite (“Page”)wird die Benutzeroberfläche erstellt. 
Microflows (Hier passiert die Logik) : Mit Mikroflows wie bentzerdefniert logik ausgeführt 

==== Anwendungslogik
Damit meinen wir, wie die Anwendung auf die Aktionen des Benutzers reagiert, d. h. was passiert, wenn der Benutzer auf die eine oder andere Taste klickt, was passiert, wenn der Benutzer die ausgefüllten Daten abschickt.

TP
Die Anwendungslogik  einer Anwendung beschreibt die konkrete Verknüpfung von Bausteinen zu einer Anwendung. Sie schreibt also die Aufrufreihenfolge der einzelnen Bausteine sowie die Parameterübergabe innerhalb der Anwendung vor.
При программирование на JavaScript разработчик получая требования продумывает полностью  Event Listeners


Mendix
The graphical notation of microflows is based on the Business Process Model and Notation (BPMN).
Nanoflows. Most of the actions run directly on the device, so there is also a speed benefit for logic which does not need access to the server.
Funktionen über Flows, Microflows und Datenmodelle

==== Qualitätskontrolle

Mendix
alle Komponenten sind vorgetestet
Test werden automatisch im Hintergrund durchgeführt
Anbindung von Selenium oder JUnit möglich 


==== Wiederverwendbarkeit

При программирование одинаковые куски кода компонуются в отдельные компоненты или функции, которые используются в дальнейшем в том же проекте. Для удобства данные функции/компоненты могут быть собраны в отдельную библиотеку, что позволит легко внедрить в другие проекты.

Mendix
Speicherung von eigenen Komponenten möglich
Wiederverwendbarkeit Plattform intern


==== Zeitaufwand


=== Literaturvergleich

=== Grenzen von Low Code

vorgebaute Komponenten / Widgets nur für häufig auftretende / wenig innovative Anwendungsfälle verfügbar
Für neue Funktionalitäten muss Low Code mit selbst geschriebenem Code unterstützt werden → je nach Innovationsgrad lohnt sich der Einsatz von Low Code nicht mehr?
dazu bei neueren Plattformen die Möglichkeit, selbst geschriebenen Code hinzuzufügen
Toolabhängigkeit. Die Anwendung selbest als auch die Datenstruktur ist von einem Tollabhängig. Vorteile mann muss keine vorinstalationen treffen. Nachteil man ist an ein tool gebunden. Möchte man auf ein anderes System umsteigen, ist dies mit viel aufwand verbunden,


== Fazit

Einfache Anwendung 
Schnelle Auf- und Umsetzung von Projekten
Praktisch für nicht innovative Funktionen
Für komplexe Anwendungen eher ungeeignet
Große Abhängigkeit von Tools

== Ausblick

=== Garter Hype Cycle

== Literaturverzeichnis
