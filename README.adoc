= Low-Code Ansatz zur Anwendungsprogrammierung
Elisabeth Lorenz, Erik Semmler, Galiia Shaekhova, Luisa Schnebelt 
:toc:
:toc-title: Gliederung
:imagesdir: ./img

== Motivation

Statistik der unbesetzten stellen von It-Kräften in deutschland. Die Anzahl steigt stetig. Es wird erkennbar, dass im jahr 2019 die zahl enorm Anstieg, dies hat hauptsächlich die Coronapandemie zu Schulden.


Hintergedanke von Low-Code: Menschen mit wenige Programmierkenntnisse können Anwendungen entwickeln.
Boilerplatecode → Abnahmen von trivialen aufgaben, dinge die man immer machen musst
Missverständnisse bei den Anforderungen 
Wartungskosten

Ergebnis Metaanalyse von 2020: Verhältnis von Softwarewartungs- und Entwicklungskosten, Mittelwerte aus einschlägigen wissenschaftlichen Arbeiten
Reduktion ermöglicht durch:
???
Softwareentwicklern werden “triviale” Aufgaben abgenommen
dadurch entsteht mehr Zeit für Aufgaben wie Problemlösung oder Algorithmenentwicklung (wofür Devs ja ausgebildet werden)
Boilerplate Code wird für templates mit generiert, Benutzeroberfläche kann 
It- Kräfte an Mangel 

== Generationen von Programmiersprachen

Low Code lässt sich in den Generationen der Programmiersprachen in die 4. Generation, die Deklarative Programmierung einordnen. 
Programmierparadigmen: ist der stil in dem eine Programmiersprache entworfen wurde


1GL:
Maschinensprache: Wie der Name bereits erläutert, gab es in der ersten Generation eine Sprache, die nur Computer verstehen konnten. Dies kann durch den Prozessors eines Computers gelesen werden und besteht aus binären und digitalen Sprachen. 
Beispiel: 

2Gl:
Assemblersprache: Der Assembler übersetzt den Assembler Programmcode/ Quellcode in ein Maschinenprogramm. Assembler Code ist für den Menschen lesbar. Erschien erstmals im Jahr 1948
Nachteile Schlechte Lesbarkeirt und wartbarkeit, ist an einem Prozesor gebunden 
Beispiel Sprache: Fortran
→ dabei Anwendungen wurden immer Komplexer, es war sehr Zeitaufwendig. Entwickler brauchten mehr Zeit, es scheiterten viele Projekte. Budget wurd gesprengt

1960er erste Softwarekrise → neue sprechen wurden eingeführt
3GL:
Prozedurale Programmierung: Die Prozedurale Programmierung ist ein Paradigma der imperativen Programmiersprache. Es definiert eine Sequentieller/ Strukturierten Ablauf von Befehlen. Wiederverwendbare Teile werden in Funktionen ausgelagert, diese müssen vom Programmierer verstanden werden.  Sie besteht aus folgen anweisungen und verschiedenen Kontrollstrukturen ( schleifen, if-bedingungen, etc….).  → Strukturierte Programierung 
in den 1970 mit der Programiersprache pascal
1970 ebenfalls objektorientierte programmiersprach
Objektorientierter Ansatz wurde 1990 in den meidsten programmiersprachen eingeführt 

→ nichte mehr prozessor abhängig


4GL. 
Ziel der Sprache höheres Abstraktniveu
Was bedeutet Abstraktion:
Vereinfachung, Kernproblem bleibt vorhanden→ auf des wesentliche konzentrieren

Nochmal mit zeitangaben Programmiersprachen
■ 1950er- bis 1960er-Jahre: 
Programmiersprache ist Assemblersprach 
Ablauf wird durch ein Flussdiagramm dargestellte

■ 
1970er-Jahre: 
Strukturierende, Dominierende programmiersprachen 
beispiel Pascal
strukturierendedarstellungstechniken werden angewendet, wie strukturierendes design
software prozesse orientieren sich am wasserfallmodell 

■ Ab 1990er-Jahre: 
Objektorientiertprogrammiersprachen werden immer belieber C++, java
Vereinheilichender prozess durch Unified Modeling Language (UML), 
orientiert sich am spiralmodell (UML)


== Model Dricen Development (MDD)

1990: AT&T-Fernverkehrsnetz im Nordosten brach zusammen 
Grund: fehlende Break Anweisung 
kleine kodierungsfehler unerwartete folgen 
Problem von Softwareentwickler und Designer entwicklung von Software ist sehr kommplex
kann diese Komplexität eingegrenzt werden durch mdd? 
Wenn wir zum Beispiel versuchen einen Wolkenkratzer ohne den Einsatz von modernenWerkzeuge wie Bulldozer und hydraulische Hebevorrichtungen zu bauen, ist zwar theoretisch machbar, aber wahrscheinlich eine sehr komplexe Aufgabe sein. Die einzig mögliche Lösung für den der zunehmenden Komplexität ist die Minimierung des Grad der zufälligen Komplexität zu minimieren.

MDD

Modelle sind zum Beispiel auch in Ingenieurwesen sehr wichtig. 
Enginere benutzen zum beispiel mathematische model um die tragfähigkeit zu analysieren 
Problem: 
Modelle werden von Hand in Code geschrieben, daher gibt es keine formale Verbindung zwischen modell und Programmcode 
Schwierig modell zu pflegen, ist mit viel aufwand verbunden und implementierungen aktuelle zu halten ist schwierig. 
Deswegen sind modelle ungenau, oft auch aufgrund von Zeitdruck 
Dokumentation deswegen nicht vertrauenswürdig

Unterschied modellbasiert und Modellgetrieben: modellbasiert wird modellerstellt und code per hand geschrieben. Dient zur Dokumentation 
Modellgetrieben nach erstellunge des modelles wird automatisch code generiert. 
Geschichte von MDD
Hohe Softwarekosten auswirkungen für Unternehmen, aber noch schlimmer ist ein schlechtes softwaredesign, das die produktivität beeinflusst
Statistiken besagen, dass ca. 70% der Software-Projekte Budget und Termin überschreiten → anhaltenden Software-Krise.

Geschichte hier nochmal rausschreben → was ist OMG
http://eddi.informatik.uni-bremen.de/SUSE/pdfs/Diplomarbeit_Radek_Eckert.pdf

andere Quellen 
Formale Modelle werden Automatisiert und lauffähiger Code wird generiert, in code übersetzt→ in lauffähige software übersetzt 
Formale Modelle besitzen eindeutige Syntax und Semantik, Beispiel hierfür ist UML (Besispeil Tool, Enterprise Architekture
anstelle der dokumentation wird durch modellierung programmcode erstellt

https://swa.informatik.uni-hamburg.de/files/abschlussarbeiten/Diplomarbeit%20Michael%20Wilk%20final.pdf

Automatisiert den Entwicklungsprozess
ziel: Kosten senken, schwierigkeitsgrad reduzieren, Qualität verbessern 
Prozess generiert das fertige Endprodukt
Im gegensatz zu gewöhnlichen softwareentwicklungsprozessen, geht es nicht um dokumentation und analyse sondern um die entwicklung entwicklungsansatz)
Normalerweise werden Modelle als Dokumentation benutzt
Entwickler haben kein wissen über den 	Quellcode

== Low Code

Low-Code ermöglicht es Personen ohne großen Programmierkenntnissen eine Anwendung zu erstellen. Somit sind Unternehmen nicht auf IT-Spezialisten angewiesen. Zum einen kann die IT-Abteilung entlastet werden und zum anderen können die Anwendungsanforderungen spezifischer gestaltet werden, da Experten des Themengebiet die Anforderungen am besten kennen. 

Mithilfe von Low-Code können mit einer Drag- und Drop-Funktion Eingabe-, Navigation-, Dropdown-Felder und Steuerelemente hinzugefügt werden. Es können verschiedene Bildschirmansichten erstellt werden, diese werden mit Hilfe von  Steuerelementen miteinander verknüpft. 

Programmierung läuft über eine grafische Benutzeroberfläche.
Entwicklungsumgebung mit der code erstellt wird
Es wird über eine grafische oberfläche code projeziert
forster research hat den begriff ins leben gerufen 


Geeignet für sogenannte Citizen Developers: 
können Programme entwickeln, können aber keine genaue Programmiersprache. Kennen sich im Bereich aus. In der Programmierung verlassen sie sich auf das Tool. Nutzer sind auch Entwicklung. 

=== Ziele von Low Code

Einbeziehen von CItizen Developers in Modellierung von Geschäftsabläufen, da Sie schon damit vertraut sind
Low-Code ermöglicht es Personen ohne großen Programmierkenntnissen eine Anwendung zu erstellen. Somit sind Unternehmen nicht auf IT-Spezialisten angewiesen. Zum einen kann die IT-Abteilung entlastet werden und zum anderen können die Anwendungsanforderungen spezifischer gestaltet werden, da Experten des Themengebiet die Anforderungen am besten kennen. 

Mithilfe von Low-Code können mit einer Drag- und Drop-Funktion Eingabe-, Navigation-, Dropdown-Felder und Steuerelemente hinzugefügt werden. Es können verschiedene Bildschirmansichten erstellt werden, diese werden mit Hilfe von  Steuerelementen miteinander verknüpft. 

Programmierung läuft über eine grafische Benutzeroberfläche.
Entwicklungsumgebung mit der code erstellt wird
Es wird über eine grafische oberfläche code projeziert
forster research hat den begriff ins leben gerufen 


Geeignet für sogenannte Citizen Developers: 
können Programme entwickeln, können aber keine genaue Programmiersprache. Kennen sich im Bereich aus. In der Programmierung verlassen sie sich auf das Tool. Nutzer sind auch Entwicklung.  von Wartungskosten in Softwareentwicklung
siehe: https://dl.gi.de/handle/20.500.12116/37795
leicht zusammengestellt werden
Schnelligkeit: 5- 10 mal schneller als traditionelle programmierung
Kosteneinsparung:
Weniger Komplex: Fokus liegt darauf software individuell anzupassen und Benutzeranforderungen zu erfüllen 
Einfache wartungsarbeiten: → wenig code anbieten wenig code muss gewartet werden. 
Wenig technische Anforderungen erforderlich. Dadurch Abteilungsleiter die sich mit dem technischen nicht auskennen aber dafür viel fachliches wissen haben. könne beser anforderunge spezifizieren 

=== Architektur von Low Code

Visual Application Modeler: 
Das Fronte-end der Platform damit arbeitet der Entwickler
Entwicklungen und implementiert alle funktionalitäten mit den ein entwickler interagiert, wie code erstellung (grafisch oder mit text) Debugging, Datenmodellierung, debugging, testen, Anwendungsversionen
Encoder:
Exportiert visuelle Anwendungsmodell  in ein json oder xml Format exportiert, ohne das Funktionalitäten verloren gehen. 
Decoder:
 Interpretiert die encodierten Daten 
Source Code Generator: 
Aus dem Format wird ein Quellcode generiert. Dies können unterschiedliche Sprachen sein. Skripte müssen enthalten sein, um mit einer Datenbank zu arbeiten. 
Compiler: Quellcode wir compiliert, geprüft ob der code correct ist
Deployer: Software bereitstellen. Zum beispiel Webanwendung


== Vergleich von Low Code und traditioneller Programmierung an Anwendungsbeispiel
Im Vergleich zur traditionellen Programmierung ermöglicht es Low-Code eine Anwendung ohne große Programmierkenntnisse, mittels einer grafischen Oberfläche zu entwickeln. 
Der Code wird automatisch erzeugt. 
Um diese Aussage zu testen, haben wir zwei Webanwendungen mit der Programmiersprache JavaScript und der Low-Code-Plattform Mendix entwickelt.

=== Vorstellung Anwendungsbeispiel

Wir haben als Beispiel beschlossen, eine Anwendung zu entwickeln, die den Prozess der Meldung eines Unfalls, der den versicherten Gegenständen eines Nutzers zugestoßen ist, vereinfacht.
Mit dieser App kann man: 

*   das versicherte Objekt des Benutzers auswählen
*   einen der vier Vorfälle auswählen und die Einzelheiten des Vorfalls eintragen
*   die Bilder des Schadens hochladen
*   weitere Details des Unfalls ausfühllen
*   zum Schluss erhält der Nutzer eine Übersicht und kann die Reklamierung absenden

Abbildung ... stellt Screenshots einer Anwendung dar, die mit ReactJS und anderen Tools entwickelt wurde. 

image:screen-react-1.png[,200] 
image:screen-react-2.png[,300]

//.Screenshots der React-Anwendung

=== verwendete Werkzeuge
Für die Erstellung dieser Anwendungen wurden verschiedene Tools verwendet.

==== ReactJS etc.

Für die JavaScript-Entwicklung wurden die Bibliotheken React und React-Bootstrap gewählt, um die Benutzeroberfläche zu erstellen. React ermöglicht es, eine interaktive Benutzeroberfläche zu erstellen, und React-Bootstrap bietet eine einfache Anpassung der Stile, ohne dass große CSS-Dateien erstellt werden müssen. Für das Backend wurden Node.js und eine MySQL-Datenbank verwendet.

==== Mendix
Mendix ist  eine vielseitige Softwareentwicklungsplattform, die es ermöglicht, mobile und Webanwendungen in großem Umfang zu erstellen, einzusetzen, zu warten und zu verbessern. [...]

https://www.netguru.com/blog/what-is-mendix

Warum wurde Mendix gewählt?

Weil Mendix ein Marktführer in seinem Bereich ist. Das IT-Beratungsunternehmen Gartner veröffentlichte im August 2022 einen Bericht zur Marktforschung über Low-Code-Unternehmensanwendungsplattformen (Enterprise Low-Code Application Platforms - LCAP) [...]. Sie verwenden den Magic Quadrant, der Markttrends wie Richtung, Reifegrad und Teilnehmer aufzeigt.
https://www.gartner.com/doc/reprints?id=1-2C8VSOAH&ct=230113&st=sb

image:magic_Quadrant.png[,500 ]
// Magic Quadrant for Enterprise Low-Code Application Platforms

Horizontal (Completeness of Vision) wird die Vollständigkeit der Vision dargestellt. Das heißt, sie spiegelt die Innovationskraft des Anbieters wider und zeigt, ob der Anbieter den Markt steuert oder ihm folgt [...].
https://www.gartner.de/de/methoden/magic-quadrants

Die Vertikale (Ability to execute) zeigt die Fähigkeit zur Ausführung. Er fasst Faktoren wie die finanzielle Rentabilität des Anbieters, seine Reaktionsfähigkeit auf dem Markt, die Produktentwicklung, die Vertriebskanäle und den Kundenstamm zusammen [...].
https://www.gartner.de/de/methoden/magic-quadrants


Darüber hinaus ist der Magic Quadrant in vier Teile unterteilt und zeigt die Wettbewerbsposition von vier Arten von Technologieanbietern in Märkten mit hohem Wachstum und signifikanter Anbieterdifferenzierung [...]:
https://www.gartner.de/de/methoden/magic-quadrants


- *Führungskräfte* (Leaders) setzen ihre aktuelle Vision gut um und sind für morgen gut aufgestellt.
- *Visionäre* (Visionaries) verstehen, wohin der Markt geht, oder haben eine Vision für die Veränderung der Marktregeln, setzen sie aber noch nicht gut um.
- *Nischenplayer* (Niche Players) konzentrieren sich erfolgreich auf ein kleines Segment oder sind unfokussiert und übertreffen andere nicht.
- *Herausforderer* (Challengers) führen heute gut aus oder dominieren vielleicht ein großes Segment, zeigen aber kein Verständnis für die Marktrichtung.


Der Magic Quadrant zeigt, dass Mendix die obere rechte Position, d.h. die führende Position, besetzt.


=== Vergleich
Auf Grund der entwickelten Beispiele wird der Vergleich in 4 Punkten erfolgen:

- GUI
- Anwendungslogik
- Qualitätskontrolle
- Wiederverwendbarkeit

==== GUI

GUI steht für "Graphical User Interface" und bezieht sich auf die Art und Weise, wie ein Computerprogramm oder ein Betriebssystem dargestellt wird. 
https://en.wikipedia.org/wiki/Graphical_user_interface 

_Traditionelle Programmierung_ +
Bei der Entwicklung in JavaScript gibt es keine grafische Benutzeroberfläche. Alle einzelnen Komponenten und Styles werden zunächst blind hinzugefügt, ohne zu wissen, wie die endgültige Benutzeroberfläche aussehen wird. Beim Start der Anwendung kann der Entwickler das Layout der einzelnen Komponenten im Code oder zunächst im Entwicklertool einrichten und dann alles in seinen Code übernehmen. Das heißt, der Entwickler muss mindestens drei Fenster verwenden (den Browser, das Entwicklertool im Browser und die Entwicklungsumgebung), um Änderungen vorzunehmen und auftretende Fehler zu sehen.

_Mendix_ +
Domänenmodell: Grafische Darstellung einer Datenbank. Besteht aus Entäitäten. Vergleichbar mit einer Datenbanktabelle. 
Auf der Seite (“Page”)wird die Benutzeroberfläche erstellt. 
Microflows (Hier passiert die Logik) : Mit Mikroflows wie bentzerdefniert logik ausgeführt 

==== Logik
Damit meinen wir, wie die Anwendung auf die Events des Benutzers reagiert, d. h. was passiert, wenn der Benutzer auf die eine oder andere Taste klickt, was passiert, wenn der Benutzer die ausgefüllten Daten abschickt.

_Traditionelle Programmierung_ +

Zunächst entscheidet der Entwickler über die Architektur der Anwendung. Und je nach Architektur ist es möglich, über zusätzlichen Entwicklungsaufwand zu sprechen. In unserem Beispiel wurde eine Client-Server-Architektur verwendet.

Wenn es um die Logik zwischen den Komponenten geht, dann ist für jeden Event eine eigene Funktion zu erstellen, die das Verhalten der Komponente definiert. Neben der Entwicklung muss der Entwickler auch Clean Code schreiben, d.h. der Programmcode muss optimiert und für andere Entwickler leicht verständlich gemacht werden.

_Mendix_ +
The graphical notation of microflows is based on the Business Process Model and Notation (BPMN).
Nanoflows. Most of the actions run directly on the device, so there is also a speed benefit for logic which does not need access to the server.
Funktionen über Flows, Microflows und Datenmodelle

==== Qualitätssicherung/Qualitätskontrolle

Die Qualität der Software ist ein wichtiger Bestandteil für den Kunden. Um die Qualität zu sichern, lohnt es sich, Softwaretests zu erstellen. Dies wird dem Kunden zeigen, wie sicher die Software ist und das tut, was er braucht.

_Traditionelle Programmierung_ +

_Mendix_ +
alle Komponenten sind vorgetestet
Test werden automatisch im Hintergrund durchgeführt
Anbindung von Selenium oder JUnit möglich 


==== Wiederverwendbarkeit

Wiederverwendbarkeit, d. h. die Wiederverwendung von Komponenten oder Codeteilen. Dies ist eine sehr beliebte Methode in der Entwicklung: Software, Webservices, Design, usw. Durch die Systematisierung der Wiederverwendung von Komponenten werden die Kosten für Projekterstellung und -pflege gesenkt, die Entwicklungszeiten verkürzt und in vielen Fällen die Qualität der Softwareprodukte verbessert. [...] 

https://habr.com/ru/company/sberbank/blog/675660/

_Traditionelle Programmierung_ 

Bei der Entwicklung mit React kann man einzelne UI-Komponenten erstellen, die später im Projekt verwendet werden, oder sie können einfach in ein anderes Projekt kopiert werden. Man kann sie auch leicht nach Bedarf ändern. Eine weitere Möglichkeit, entwickelte Funktionen und Komponenten zu verwenden, besteht darin, eine eigene Bibliothek dieser Komponenten zu erstellen. Diese Bibliothek kann in andere Projekte importiert werden. 

_Mendix_

Speicherung von eigenen Komponenten möglich
Wiederverwendbarkeit Plattform intern


==== Zeitaufwand

Das Interessanteste an diesem Vergleich ist die Entwicklungszeit. Wie der Begriff "Low Code" schon sagt, verkürzt er die Entwicklungszeit.

[width="100%",options="header", cols="^,^,^"]
|===
|_Konventionell (ReactJS)_ |Aufgabenteil |_Low Code (Mendix)_
|1 h |Einarbeitung |10 h
|3,5 h |Aufsetzen des Projekts |0 h
|40 h |Entwicklungszeit |15h
|44,5 h |*Gesamt* |25 h
|===

_Traditionelle Programmierung_

_Mendix_


=== Literaturvergleich

=== Grenzen von Low Code

vorgebaute Komponenten / Widgets nur für häufig auftretende / wenig innovative Anwendungsfälle verfügbar
Für neue Funktionalitäten muss Low Code mit selbst geschriebenem Code unterstützt werden → je nach Innovationsgrad lohnt sich der Einsatz von Low Code nicht mehr?
dazu bei neueren Plattformen die Möglichkeit, selbst geschriebenen Code hinzuzufügen
Toolabhängigkeit. Die Anwendung selbest als auch die Datenstruktur ist von einem Tollabhängig. Vorteile mann muss keine vorinstalationen treffen. Nachteil man ist an ein tool gebunden. Möchte man auf ein anderes System umsteigen, ist dies mit viel aufwand verbunden,


== Fazit

Einfache Anwendung 
Schnelle Auf- und Umsetzung von Projekten
Praktisch für nicht innovative Funktionen
Für komplexe Anwendungen eher ungeeignet
Große Abhängigkeit von Tools

== Ausblick

=== Garter Hype Cycle

== Literaturverzeichnis
